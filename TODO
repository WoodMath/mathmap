-*- outline -*-

* 1.3.3

** General

** GIMP Plug-In

** Language
HSL color space (for color gimp layer mode)
figure out how to do calling between pixel/non-pixel filters (eg mugl in composer)
statement for importing filters

** Packaging

** Rendering
reasonable default size
specifiable size
antialiasing from rendered images
lazy rendering
use image/row/column const stuff for rendering

** Designer

** Native filters
gaussian blur
convolution

** Compiler

** Filters
color gimp layer mode

* 1.3.x

** Designer
catch and forbid recursive compositions

** GIMP Plug-In
auto-completion?
Histogram
ask to save before quitting or selecting another expression or composition
Different fast image source size per drawable
Adapt fast image source size to preview size
zoom via preview (?)
Get preview background gray from GtkStyle

** Language
provide syntactic sugar for returning images instead of colors
indirectly recursive filters
Hypercomplex-Complex multiplication
XYZ, Lab color space support
filters as first class values

** Command Line Tool
Colors as definable user values

** General
Logarithmic sliders
Debug tuples
Better source reference for error messages
Remove i18n?

** Packaging
Real dependencies

** Image Processing

** Examples

** Compiler
eliminate negative index values. then every value must have a valid def.
check why lots of ops (like RED_FLOAT) are not foldable
pass colors as tuples
more arithmetic optimizations (like a*c1+a*c2 -> a*(c1+c2))
catch duplicate filter names
passing of colors, curves and gradients to filters
filter call argument checking
number*image must trigger an error!
optimization for filters which use the "current" pixel
Copy elimination for phis in pre-native code
Remove dead whiles
XY constants for interpreter code

** Documentation/Homepage

* long term

** GIMP Plug-In
Preview in thread
UI names for user values

** General
Edge behaviour as image attributes

* probably never

** Blender
noise, gamma, vector/matrix division do not work
edge behaviour is not implemented
antialiasing and supersampling are not implemented






short circuit execution for && in compiler
sqrt for complex
rewrite HACKING and include it in distro





unload c code in openstep
library








macos:
gruen fuer ints, floats und konstanten duenkler
"Informational Text" in library?
tool tips
library at startup




manual: WH,W,H statt wh,w,h
koordinatensystem erklaeren
scanner default action auf error!

short circuit logic eval


> (i) Die Möglichkeit, bei 'user_slider(name,minimum,maximum)' als 'maximum'
> und 'minimum' Ausdrücke anzugeben, die von den Variablen 'X(nil:1)' und
> 'Y(nil:1)' abhängen.
> 
> (ii) Einen voreingestellten Wert für 'userslider' festzulegen (mit der
> gleichen Methode wie unter (i)).
> 
> (iii) Die Möglichkeit über den Dialog 'User Values' Werte direkt
> einzugeben (sowas wie das Eigabefeld <input> in HTML).


macos x:
  altivec
  multithreading (smp)
  movies (realtime!)



web pages:

  http://www.sf.edu/jhlavacek/gallery.html
  http://www.mai.liu.se/~halun/complex/complex.html
  http://www.ukuug.org/events/linux2001/papers/html/TRathborne_mathmap-fractals/Paper.html




gimptool in Makefile statt gimp-config verwenden
radio buttons
NaN und Infty ausprobieren
init optimization
save expression in image




normalisierung von matrizen (matrix/determinante)
inverse matrix
pixel konvertieren schneller machen
abs cool machen (abs([-3,4]) sollt 5 sein, ned [3,4])











#konrad stania
winkelrotz=0;
winkelrothor=0;
shiftx=0;
shifty=0;
fa=1;
fb=0;
fc=0;
fd=0;
rotmz=m3x3:[cos(-winkelrotz),-sin(-winkelrotz),0,sin(-winkelrotz),cos(-winkelrotz),0,0,0,1];
rotmh=m3x3:[1,0,0,0,cos(-winkelrothor),-sin(-winkelrothor),0,sin(-winkelrothor),cos(-winkelrothor)];
focus=max(X,Y)*5;
rad=r/R;
trafomat=rotmz*rotmh;
koord1ra=ra:[R*(fa*rad+fb*rad^2+fc*rad^3+fd*rad^4),a];
koord1x=nil:[koord1ra[0]*cos(koord1ra[1])];
koord1y=nil:[koord1ra[0]*sin(koord1ra[1])];
koord1z=0;
koordtraf=[koord1x,koord1y,koord1z]*trafomat;
origValXY(koordtraf[0]/(koordtraf[2]+focus)*focus-X*shiftx,koordtraf[1]/(koordtraf[2]+focus)*focus-Y*shifty)


Remarks:
winkelrotz   : rotate the image (clockwise)
winkelrothor : perspectively tilt the image around horizont.
               In architectural fotography used to make vertical lines strictly paralell
shiftx/shifty: shift the resulting imgae
fa ... fd    : to scale image and remove optical distortion
               in polar koordinates radius = fa * radius + fb * radius ^ 2 + fc * radius ^ 3 + fd * radius ^ 4
















# make vertically seamless
# Thanks to Martin Weber
origValXY(x,y-sign(y)*Y)*abs(y)/Y+origVal(xy)*(1-(abs(y)/Y))

# make horizontally seamless
# Thanks to Martin Weber
origValXY(x-sign(x)*X,y)*abs(x)/X+origVal(xy)*(1-(abs(x)/X))







g = user_slider("granularity",0,50);
nxy = xy/R*g;
n = noise3([nxy[0],nxy[1],t*g]);
grayColor(n)*0.5+0.5








g = user_slider("granularity",0,50);
nxy = xy/R*g;
point = [nxy[0],nxy[1],t*g];
offset = (point + 0.5) / user_slider("offset granularity",0,50);
n1y = user_slider("n1y",0,10);
n1z = user_slider("n1z",0,10);
offset = [noise1(offset[0]),noise1(offset[1]),noise1(offset[2])] * user_slider("distortion",0,10);
#grayColor(offset[0]*0.5+0.5)
n = noise3(point+offset);
grayColor(n)*0.5+0.5












defun map ((nil:1)->nil:1 f, _:_ x)
    construct(x.tag:x.length, lambda (nil:1 i) f(x[i]) end)
end

defun map ((nil:1, nil:1)->nil:1 f, T:L x, T:L y)
    construct(x.tag:x.length, lambda (nil:1 i) f(x[i],y[i]) end)
end

defun __add (ri:2 a, ri:2 b)
    ri:[a[0]+b[0],a[1]+b[1]]
end

defun __add (T:L a, _:1 b)
    map(lambda (nil:1 x) x+b end, a)
end

defun __add (T:L a, T:L b)
    map(lambda (nil:1 x, nil:1 y)
            x+y
        end, a, b)
end

defun __mul (ri:2 a, ri:2 b)
    ri:[a[0]*b[0] - a[1]*b[1], a[0]*b[1] + b[0]*a[1]]
end

defun __div (ri:2 a, ri:2 b)
    if b == ri:[0,0] then
        ri:[0,0]
    else
        q = b[0] * b[0] + b[1] * b[1];
        ri:[(a[0]*b[0] + a[1]*b[1]) / q, (-a[0]*b[1] + b[0]*a[1]) / q]
    end
end








dx=-5;
dy=-5;
sum=rgba:[0,0,0,0];
num=0;
while dy < 6 do
    while dx < 6 do
        sum = sum + origVal(xy+xy:[dx,dy]);
        num = num + 1;
        dx = dx + 1
    end;
    dy = dy + 1
end;
sum / num













alpha = user_slider("alpha",0,360);
dir = xy:[cos(alpha),sin(alpha)];
ndir = xy:[-dir[1],dir[0]];
p = xy / m2x2:[dir[0],-ndir[0],
               dir[1],-ndir[1]];
pt = dir * p[0];
vec = xy - pt;
dist = -p[1] / R;
pos = 0.5 + p[0] / R / 2;
lower = user_curve("lower",pos) * 2 - 0.5;
upper = user_curve("upper",pos) * 2 - 0.5;
f = ((dist + 1) / 2 - lower) / (upper - lower);
origVal(pt + ndir * (f*2-1) * )R









# fractal noise
z = user_slider("z",0,10);
depth = floor(user_slider("depth",1,10));
pers = user_slider("persistence",0,1);
g = user_slider("granularity",0,50);
nxy = xy / R * g;
xyz = [nxy[0],nxy[1],z];
i = 1;
sum = 0;
max = 0;
while i < depth + 1 do
    sum = sum + noise(xyz*i) * (pers^i);
    max = max + (pers ^ i);
    i = i + 1
end;
grayColor(sum / (max * 2) + 0.5)









# fractal noise displace
z = user_float("z",0,10);
depth = user_int("depth",1,10);
pers = user_float("persistence",0,1);
g = user_float("granularity",0,50);
strength = user_float("strength",0,50);
nxy = xy / R * g;
xyz = [nxy[0],nxy[1],z];
i = 1;
sum = xy:[0,0];
max = 0;
while i < depth + 1 do
    persi = pers ^ i;
    sum = sum + xy:[noise(xyz*i),noise(xyz*i+[3.1415,2.71234,5.4322])] * persi;
    max = max + persi;
    i = i + 1
end;
val = sum / max;
origVal(xy + val * strength)













# smooth mugl
sl=30;
nx=floor(x/sl-0.5); ny=floor(y/sl-0.5);
alpha=[0,0,0,0];
radii=[0,0,0,0];
phii=[0,0,0,0];
xc=[0,0,0,0];
yc=[0,0,0,0];
heuslfaktor=sl/user_slider("size",1.2,5);
i=0; while i < 4 do
    ix=nx+i%2;
    iy=ny+floor(i/2);
    xc[i]=(ix+0.5)*sl;
    yc[i]=(iy+0.5)*sl;
    alpha[i]=(noise([ix*0.3,iy*0.3,0])+1)*180+t*360;
    kurde=toRA(xy:[x-xc[i],y-yc[i]])+ra:[0,pmod(alpha[i],360)];
    phii[i]=kurde[1];
    radii[i]=heuslfaktor*(1+noise([xc[i]+cos(kurde[1]),yc[i]+sin(kurde[1]),0]*2)*0.7);
    i = i + 1
end;
i=0;found=0;
while !found && i<4 do
    heuslkurde=toRA(xy:[x-xc[i],y-yc[i]])+ra:[0,alpha[i]];
    if heuslkurde[0]<radii[i] then
        found = 1
    else
        i=i+1
    end
end;
if i >= 4 then
    rgba:[0,0,1,1]
else
    if heuslkurde[0] < radii[i]-1.5 then
        origVal(toXY(heuslkurde)+xy:[xc[i],yc[i]])
    else
        rgba:[0,0,0,1]
    end
end







dur = user_slider("duration",0,5);
amp = exp(-t / dur);
front = t * R * 2;
dropxy = xy:[0,0];
dropr = toRA(xy - dropxy)[0];
disp = sin(dropr * 360 / user_slider("length",0,100) + t * 360 * user_slider("speed",0,100)) * cos(clamp(if front == 0 then 90 else dropr/front end * 90,0,90))^2 * user_slider("amp",0,100) * amp;
dispxy = toXY(ra:[disp,0]);
origVal(xy+dispxy)







dur = user_slider("duration",0,5);
amp = exp(-t / dur);
front = t * R * 2;
n = user_slider("num drops",1,20);
lastt = user_slider("t of last drop",0,1);
i = 0;
dispxy = xy:[0,0];
while i < n do
    dropt = scale(noise([n * pi, 0 * pi, 0]),-1,1,0,lastt);
    dropxy = xy:[noise([n * pi, pi, 0]),noise([n * pi, 2 * pi, 0])] * XY;
    dropr = (toRA(xy - dropxy))[0];
    disp = sin(dropr * 360 / user_slider("length",0,100) + t * 360 * user_slider("speed",0,100)) * cos(clamp(if front == 0 then 90 else dropr/front end * 90,0,90))^2 * user_slider("amp",0,100) * amp;
    dispxy = dispxy + toXY(ra:[disp,0]);
    i = i + 1
end;
origVal(xy+dispxy)










# frame diff
(origVal(xy,frame)-origVal(xy,frame-1))/2+rgba:[1/2,1/2,1/2,1]




# fade
origVal(xy,image:0,frame)*(1-t)+origVal(xy,image:1,frame)*t









# movie spiral
q=sin((r-a*0.1)*10+t*5*360)*0.5+0.5;
origVal(xy,image:0,frame)*(1-q)+origVal(xy,image:1,frame)*q









# pink ball
p=toHSVA(origVal(xy));
hg=0.9647;
dh=min(abs(p[0]-hg),abs(p[0]-(hg-1)));
ds=p[1]-0.6941;
if dh*dh+ds*ds < 0.05 then rgba:[1,1,1,1] else rgba:[0,0,0,1] end




# yellow ball
p=toHSVA(origVal(xy));
dh=p[0]-0.2;
ds=p[1]-0.65;
if dh*dh+ds*ds < 0.01 then rgba:[1,1,1,1] else rgba:[0,0,0,1] end




# green ball
p=toHSVA(origVal(xy));
dh=p[0]-0.3725;
ds=p[1]-0.7;
if dh*dh < 0.003 then rgba:[1,1,1,1] else rgba:[0,0,0,1] end






# slide (left->right) transition
if (x+X)/W < t then origVal(xy,image:0,frame) else origVal(xy,image:1,frame) end

st=15;p=clamp((x+X-t*W)/st+0.5,0,1);origVal(xy,image:0,frame)*(1-p)+origVal(xy,image:1,frame)*p


























craig kaplan:

Okay.  Well, part of the talk was about how some of Escher's
patterns with shapes that diminish towards the centre of the
plane are just mathematical transformations of simple
Euclidean patterns.  I demonstrated this fact by carrying
the transformation out on a couple of patterns.  You can see
the results here:

        http://www.cgl.uwaterloo.ca/~csk/tmp/butterflies.png
        http://www.cgl.uwaterloo.ca/~csk/tmp/butterflies_merc.png
        http://www.cgl.uwaterloo.ca/~csk/tmp/snakes.jpg
        http://www.cgl.uwaterloo.ca/~csk/tmp/snakes_merc.png

For reference, the transformation is to put the coordinate 
axes of the complex plane at the center of the circular picture
and to pass the image through the function f(z)=log(z) in
the complex plane.  More precisely, I used this function in 
MathMap:

        y = y/H*360.0*1.6;
        cy = cos( ay );
        sy = sin( ay );
        ax =-0.8+(x+X)/W*9;
        ex = exp( ax );
        mx = ex*cy;
        my = ex*sy;

        ssx = mx*3;
        ssy = my*3;

        origVal( xy:[ssx+4,ssy-1] )

